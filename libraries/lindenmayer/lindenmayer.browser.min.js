var LSystem=function(){"use strict";function t(t){let s,i=t[0].match(/(.+)<(.)/),o=t[0].match(/(.)>(.+)/);if(null===i&&null===o)return t;let e=t[1].successor||t[1].successors?t[1]:{successor:t[1]};return null!==i&&(s=i[2],e.leftCtx=i[1]),null!==o&&(s=o[1],e.rightCtx=o[2]),[s,e]}function s(t){if("string"!=typeof t&&t instanceof String==!1)return t;let s=[];for(let i of t)s.push({symbol:i});return s}function i(t,i){return t[1]=function t(i,o){if(i.hasOwnProperty("successors"))for(var e=0;e<i.successors.length;e++)i.successors[e]=t(i.successors[e],o);else!1===i.hasOwnProperty("successor")&&(i={successor:i});return o&&i.hasOwnProperty("successor")&&(i.successor=s(i.successor)),i}(t[1],i),t}class LSystem{constructor({axiom:t="",productions:s,finals:i,branchSymbols:o="[]",ignoredSymbols:e="+-&^/|\\",allowClassicSyntax:r=!0,classicParametricSyntax:n=!1,forceObjects:c=!1,debug:a=!1}){this.ignoredSymbols=e,this.debug=a,this.branchSymbols=o,this.allowClassicSyntax=r,this.classicParametricSyntax=n,this.forceObjects=c,this.setAxiom(t),this.clearProductions(),s&&this.setProductions(s),i&&this.setFinals(i)}setAxiom(t){this.axiom=this.forceObjects?s(t):t}getRaw(){return this.axiom}getString(t=!0){return"string"==typeof this.axiom?this.axiom:!0===t?this.axiom.reduce((t,s)=>{if(void 0===s.symbol)throw console.log("found:",s),new Error("L-Systems that use only objects as symbols (eg: {symbol: 'F', params: []}), cant use string symbols (eg. 'F')! Check if you always return objects in your productions and no strings.");return t+s.symbol},""):JSON.stringify(this.axiom)}setProduction(s,o,e=!1){let r=[s,o];if(void 0===r)throw new Error("no production specified.");if(o.successor&&o.successors)throw new Error('You can not have both a "successor" and a "successors" field in your production!');if(!0===this.allowClassicSyntax&&(r=t(r)),(r=i(r,this.forceObjects))[1].isStochastic=void 0!==r[1].successors&&r[1].successors.every(t=>void 0!==t.weight),r[1].isStochastic){r[1].weightSum=0;for(let t of r[1].successors)r[1].weightSum+=t.weight}let n=r[0];if(!0===e&&this.productions.has(n)){let t=this.productions.get(n),s=t.successor,i=t.successors;s&&!i&&(t={successors:[t]}),t.successors.push(r[1]),this.productions.set(n,t)}else this.productions.set(n,r[1])}setProductions(t){if(void 0===t)throw new Error("no production specified.");this.clearProductions();for(let s of Object.entries(t)){let t=s[0],i=s[1];this.setProduction(t,i,!0)}}clearProductions(){this.productions=new Map}setFinal(t,s){let i=[t,s];if(void 0===i)throw new Error("no final specified.");this.finals.set(i[0],i[1])}setFinals(t){if(void 0===t)throw new Error("no finals specified.");this.finals=new Map;for(let s in t)t.hasOwnProperty(s)&&this.setFinal(s,t[s])}getProductionResult(t,s,i,o,e=!1){let r=void 0!==t.leftCtx||void 0!==t.rightCtx,n=!1,c=!0;if(void 0!==t.condition&&!1===t.condition({index:s,currentAxiom:this.axiom,part:i,params:o})?c=!1:r&&(void 0!==t.leftCtx&&void 0!==t.rightCtx?c=this.match({direction:"left",match:t.leftCtx,index:s,branchSymbols:this.branchSymbols,ignoredSymbols:this.ignoredSymbols}).result&&this.match({direction:"right",match:t.rightCtx,index:s,branchSymbols:this.branchSymbols,ignoredSymbols:this.ignoredSymbols}).result:void 0!==t.leftCtx?c=this.match({direction:"left",match:t.leftCtx,index:s,branchSymbols:this.branchSymbols,ignoredSymbols:this.ignoredSymbols}).result:void 0!==t.rightCtx&&(c=this.match({direction:"right",match:t.rightCtx,index:s,branchSymbols:this.branchSymbols,ignoredSymbols:this.ignoredSymbols}).result)),!1===c)n=!1;else if(t.successors){let e,r;t.isStochastic&&(r=Math.random()*t.weightSum,e=0);for(let c of t.successors){if(t.isStochastic&&(e+=c.weight)<r)continue;let a=this.getProductionResult(c,s,i,o,!0);if(void 0!==a&&!1!==a){n=a;break}}}else n="function"==typeof t.successor?t.successor({index:s,currentAxiom:this.axiom,part:i,params:o}):t.successor;return n||(e?n:i)}applyProductions(){let t="string"==typeof this.axiom?"":[],s=0;for(let i of this.axiom){let o=i.symbol||i,e=i.params||[],r=i;if(this.productions.has(o)){let t=this.productions.get(o);r=this.getProductionResult(t,s,i,e)}"string"==typeof t?t+=r:r instanceof Array?t.push(...r):t.push(r),s++}return this.axiom=t,t}iterate(t=1){let s;this.iterations=t;for(let i=0;i<t;i++)s=this.applyProductions();return s}final(t){let s=0;for(let i of this.axiom){let o=i;if("object"==typeof i&&i.symbol&&(o=i.symbol),this.finals.has(o)){let e=this.finals.get(o),r=typeof e;if("function"!==r)throw Error("'"+o+"' has an object for a final function. But it is __not a function__ but a "+r+"!");e({index:s,part:i},t)}s++}}match({axiom_:t,match:s,ignoredSymbols:i,branchSymbols:o,index:e,direction:r}){let n=0,c=0;t=t||this.axiom,void 0===o&&(o=void 0!==this.branchSymbols?this.branchSymbols:[]),void 0===i&&(i=void 0!==this.ignoredSymbols?this.ignoredSymbols:[]);let a,l,h,u,f,m,d,b=[];if("right"===r){if(u=m=1,h=e+1,f=0,d=s.length,o.length>0){var g=o;a=g[0],l=g[1]}}else{if("left"!==r)throw Error(r,"is not a valid direction for matching.");if(u=m=-1,h=e-1,f=s.length-1,d=-1,o.length>0){var y=o;l=y[0],a=y[1]}}for(;h<t.length&&h>=0;h+=u){let o=t[h].symbol||t[h],e=s[f];if(o===e){if((0===n||c>0)&&(o===a?(c++,n++,f+=m):o===l?(c=Math.max(0,c-1),n=Math.max(0,n-1),0===c&&(f+=m)):(b.push(h),f+=m)),f===d)return{result:!0,matchIndices:b}}else if(o===a)n++,c>0&&c++;else if(o===l)n=Math.max(0,n-1),c>0&&(c=Math.max(0,c-1));else if((0===n||c>0&&e!==l)&&!1===i.includes(o))return{result:!1,matchIndices:b}}return{result:!1,matchIndices:b}}}return LSystem.getStringResult=LSystem.getString,LSystem.transformClassicStochasticProductions=function(t){return function(){let s=t,i=s.length,o=Math.random();for(let t=0;t<i;t++)if(o<=(t+1)/i)return s[t];console.error("Should have returned a result of the list, something is wrong here with the random numbers?.")}},LSystem.transformClassicCSProduction=t,LSystem.transformClassicParametricAxiom=function(t){let s=t.replace(/\s+/g,"").split(/[\(\)]/),i=[];for(let t=0;t<s.length-1;t+=2){let o=s[t+1].split(",").map(Number);i.push({symbol:s[t],params:o})}},LSystem.testClassicParametricSyntax=function(t){return/\(.+\)/.test(t)},LSystem}();
