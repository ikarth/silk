"use strict";function t(t){return function(){let s=t,i=s.length,o=Math.random();for(let t=0;t<i;t++){if(o<=(t+1)/i)return s[t]}console.error("Should have returned a result of the list, something is wrong here with the random numbers?.")}}function s(t){return/\(.+\)/.test(t)}function i(t){let s=t.replace(/\s+/g,"").split(/[\(\)]/),i=[];for(let t=0;t<s.length-1;t+=2){let o=s[t+1].split(",").map(Number);i.push({symbol:s[t],params:o})}}function o(t){let s,i=t[0].match(/(.+)<(.)/),o=t[0].match(/(.)>(.+)/);if(null===i&&null===o)return t;let e=t[1].successor||t[1].successors?t[1]:{successor:t[1]};return null!==i&&(s=i[2],e.leftCtx=i[1]),null!==o&&(s=o[1],e.rightCtx=o[2]),[s,e]}function e(t){if("string"!=typeof t&&t instanceof String==!1)return t;let s=[];for(let i of t)s.push({symbol:i});return s}function r(t,s){if(t.hasOwnProperty("successors"))for(var i=0;i<t.successors.length;i++)t.successors[i]=r(t.successors[i],s);else!1===t.hasOwnProperty("successor")&&(t={successor:t});return s&&t.hasOwnProperty("successor")&&(t.successor=e(t.successor)),t}function n(t,s){return t[1]=r(t[1],s),t}class LSystem{constructor({axiom:t="",productions:s,finals:i,branchSymbols:o="[]",ignoredSymbols:e="+-&^/|\\",allowClassicSyntax:r=!0,classicParametricSyntax:n=!1,forceObjects:c=!1,debug:a=!1}){this.ignoredSymbols=e,this.debug=a,this.branchSymbols=o,this.allowClassicSyntax=r,this.classicParametricSyntax=n,this.forceObjects=c,this.setAxiom(t),this.clearProductions(),s&&this.setProductions(s),i&&this.setFinals(i)}setAxiom(t){this.axiom=this.forceObjects?e(t):t}getRaw(){return this.axiom}getString(t=!0){return"string"==typeof this.axiom?this.axiom:!0===t?this.axiom.reduce((t,s)=>{if(void 0===s.symbol)throw console.log("found:",s),new Error("L-Systems that use only objects as symbols (eg: {symbol: 'F', params: []}), cant use string symbols (eg. 'F')! Check if you always return objects in your productions and no strings.");return t+s.symbol},""):JSON.stringify(this.axiom)}setProduction(t,s,i=!1){let e=[t,s];if(void 0===e)throw new Error("no production specified.");if(s.successor&&s.successors)throw new Error('You can not have both a "successor" and a "successors" field in your production!');if(!0===this.allowClassicSyntax&&(e=o(e)),(e=n(e,this.forceObjects))[1].isStochastic=void 0!==e[1].successors&&e[1].successors.every(t=>void 0!==t.weight),e[1].isStochastic){e[1].weightSum=0;for(let t of e[1].successors)e[1].weightSum+=t.weight}let r=e[0];if(!0===i&&this.productions.has(r)){let t=this.productions.get(r),s=t.successor,i=t.successors;s&&!i&&(t={successors:[t]}),t.successors.push(e[1]),this.productions.set(r,t)}else this.productions.set(r,e[1])}setProductions(t){if(void 0===t)throw new Error("no production specified.");this.clearProductions();for(let s of Object.entries(t)){let t=s[0],i=s[1];this.setProduction(t,i,!0)}}clearProductions(){this.productions=new Map}setFinal(t,s){let i=[t,s];if(void 0===i)throw new Error("no final specified.");this.finals.set(i[0],i[1])}setFinals(t){if(void 0===t)throw new Error("no finals specified.");this.finals=new Map;for(let s in t)t.hasOwnProperty(s)&&this.setFinal(s,t[s])}getProductionResult(t,s,i,o,e=!1){let r=void 0!==t.leftCtx||void 0!==t.rightCtx,n=!1,c=!0;if(void 0!==t.condition&&!1===t.condition({index:s,currentAxiom:this.axiom,part:i,params:o})?c=!1:r&&(void 0!==t.leftCtx&&void 0!==t.rightCtx?c=this.match({direction:"left",match:t.leftCtx,index:s,branchSymbols:this.branchSymbols,ignoredSymbols:this.ignoredSymbols}).result&&this.match({direction:"right",match:t.rightCtx,index:s,branchSymbols:this.branchSymbols,ignoredSymbols:this.ignoredSymbols}).result:void 0!==t.leftCtx?c=this.match({direction:"left",match:t.leftCtx,index:s,branchSymbols:this.branchSymbols,ignoredSymbols:this.ignoredSymbols}).result:void 0!==t.rightCtx&&(c=this.match({direction:"right",match:t.rightCtx,index:s,branchSymbols:this.branchSymbols,ignoredSymbols:this.ignoredSymbols}).result)),!1===c)n=!1;else if(t.successors){let e,r;t.isStochastic&&(r=Math.random()*t.weightSum,e=0);for(let c of t.successors){if(t.isStochastic&&(e+=c.weight)<r)continue;let a=this.getProductionResult(c,s,i,o,!0);if(void 0!==a&&!1!==a){n=a;break}}}else n="function"==typeof t.successor?t.successor({index:s,currentAxiom:this.axiom,part:i,params:o}):t.successor;return n||(e?n:i)}applyProductions(){let t="string"==typeof this.axiom?"":[],s=0;for(let i of this.axiom){let o=i.symbol||i,e=i.params||[],r=i;if(this.productions.has(o)){let t=this.productions.get(o);r=this.getProductionResult(t,s,i,e)}"string"==typeof t?t+=r:r instanceof Array?t.push(...r):t.push(r),s++}return this.axiom=t,t}iterate(t=1){let s;this.iterations=t;for(let i=0;i<t;i++)s=this.applyProductions();return s}final(t){let s=0;for(let i of this.axiom){let o=i;if("object"==typeof i&&i.symbol&&(o=i.symbol),this.finals.has(o)){let e=this.finals.get(o),r=typeof e;if("function"!==r)throw Error("'"+o+"' has an object for a final function. But it is __not a function__ but a "+r+"!");e({index:s,part:i},t)}s++}}match({axiom_:t,match:s,ignoredSymbols:i,branchSymbols:o,index:e,direction:r}){let n=0,c=0;t=t||this.axiom,void 0===o&&(o=void 0!==this.branchSymbols?this.branchSymbols:[]),void 0===i&&(i=void 0!==this.ignoredSymbols?this.ignoredSymbols:[]);let a,l,h,u,f,m,d,b=[];if("right"===r){if(u=m=1,h=e+1,f=0,d=s.length,o.length>0){var g=o;a=g[0],l=g[1]}}else{if("left"!==r)throw Error(r,"is not a valid direction for matching.");if(u=m=-1,h=e-1,f=s.length-1,d=-1,o.length>0){var y=o;l=y[0],a=y[1]}}for(;h<t.length&&h>=0;h+=u){let o=t[h].symbol||t[h],e=s[f];if(o===e){if((0===n||c>0)&&(o===a?(c++,n++,f+=m):o===l?(c=Math.max(0,c-1),n=Math.max(0,n-1),0===c&&(f+=m)):(b.push(h),f+=m)),f===d)return{result:!0,matchIndices:b}}else if(o===a)n++,c>0&&c++;else if(o===l)n=Math.max(0,n-1),c>0&&(c=Math.max(0,c-1));else if((0===n||c>0&&e!==l)&&!1===i.includes(o))return{result:!1,matchIndices:b}}return{result:!1,matchIndices:b}}}LSystem.getStringResult=LSystem.getString,LSystem.transformClassicStochasticProductions=t,LSystem.transformClassicCSProduction=o,LSystem.transformClassicParametricAxiom=i,LSystem.testClassicParametricSyntax=s,module.exports=LSystem;
